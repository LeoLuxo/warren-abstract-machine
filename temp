pub mod parser {
    use std::{fmt::Debug, ops::Index, str::FromStr};
    use anyhow::{bail, ensure, Context, Ok, Result};
    use logos::{Lexer, Logos};
    use regex::Regex;
    use crate::{
        ast::{
            Atom, Atoms, Clause, Clauses, Constant, Fact, Functor, Rule, Structure, Term,
            Terms, Variable,
        },
        machine_types::VarRegister, static_regex, subst::Substitution,
    };
    impl FromStr for VarRegister {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self> {
            let reg = {
                ({
                    {
                        const RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
                        RE.get_or_init(|| Regex::new(r"^(?:X|A)(\d+)$").unwrap())
                    }
                        .captures(
                            match s.trim() {
                                tmp => {
                                    {
                                        ::std::io::_eprint(
                                            format_args!(
                                                "[{0}:{1}:{2}] {3} = {4:#?}\n",
                                                "src\\parser.rs",
                                                62u32,
                                                13u32,
                                                "s.trim()",
                                                &tmp,
                                            ),
                                        );
                                    };
                                    tmp
                                }
                            },
                        )
                        .context({
                            let res = ::alloc::fmt::format(
                                format_args!("Regex parsing error in \'{0}\'", s),
                            );
                            res
                        })?
                        .extract::<1>()
                        .1
                })[0]
            };
            let reg = reg.parse::<usize>()?.into();
            Ok(reg)
        }
    }
    impl FromStr for Functor {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self> {
            let [name, arity] = {
                {
                    const RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
                    RE.get_or_init(|| Regex::new(r"^(\w+?)/(\d+?)$").unwrap())
                }
                    .captures(
                        match s.trim() {
                            tmp => {
                                {
                                    ::std::io::_eprint(
                                        format_args!(
                                            "[{0}:{1}:{2}] {3} = {4:#?}\n",
                                            "src\\parser.rs",
                                            73u32,
                                            23u32,
                                            "s.trim()",
                                            &tmp,
                                        ),
                                    );
                                };
                                tmp
                            }
                        },
                    )
                    .context({
                        let res = ::alloc::fmt::format(
                            format_args!("Regex parsing error in \'{0}\'", s),
                        );
                        res
                    })?
                    .extract::<2>()
                    .1
            };
            Ok(Self {
                name: name.to_owned().into(),
                arity: arity.parse()?,
            })
        }
    }
    impl FromStr for Substitution {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> Result<Self> {
            ::core::panicking::panic("not yet implemented")
        }
    }
    impl Parsable for Clauses {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            parser.match_sequence::<Clause>("\n", None).map(Into::into)
        }
    }
    impl Parsable for Clause {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            Err(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("None of the either!() options worked"),
                        );
                        error
                    }),
                )
                .or_else(|_| parser.match_type::<Fact>().map(Into::into))
                .or_else(|_| parser.match_type::<Rule>().map(Into::into))
        }
    }
    impl Parsable for Fact {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            let atom = parser.match_type::<Atom>()?;
            parser.match_token(".")?;
            Ok(atom.into())
        }
    }
    impl Parsable for Rule {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            let head = parser.match_type::<Atom>()?;
            parser.match_token(":-")?;
            let body = parser.match_sequence::<Atom>(",", Some(1))?;
            parser.match_token(".")?;
            Ok((head, body.into()).into())
        }
    }
    impl Parsable for Atoms {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            parser.match_sequence::<Atom>(",", None).map(Into::into)
        }
    }
    impl Parsable for Atom {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            let name = parser.match_identifier()?.to_owned();
            parser.match_token("(")?;
            let terms = parser.match_sequence::<Term>(",", Some(1))?;
            parser.match_token(")")?;
            Ok((name.into(), terms.into()).into())
        }
    }
    impl Parsable for Terms {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            parser.match_sequence::<Term>(",", None).map(Into::into)
        }
    }
    impl Parsable for Term {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            Err(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("None of the either!() options worked"),
                        );
                        error
                    }),
                )
                .or_else(|_| parser.match_type::<Structure>().map(Into::into))
                .or_else(|_| parser.match_type::<Variable>().map(Into::into))
                .or_else(|_| parser.match_type::<Constant>().map(Into::into))
        }
    }
    impl Parsable for Structure {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            let name = parser.match_identifier()?.to_owned();
            parser.match_token("(")?;
            let terms = parser.match_sequence::<Term>(",", Some(1))?;
            parser.match_token(")")?;
            Ok((name.into(), terms.into()).into())
        }
    }
    impl Parsable for Constant {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            let constant = Err(
                    ::anyhow::__private::must_use({
                        let error = ::anyhow::__private::format_err(
                            format_args!("None of the either!() options worked"),
                        );
                        error
                    }),
                )
                .or_else(|_| parser.match_signed_integer().map(ToOwned::to_owned))
                .or_else(|_| {
                    parser.match_lowercase_identifier().map(ToOwned::to_owned)
                })?;
            Ok(constant.into())
        }
    }
    impl Parsable for Variable {
        fn parser_match(parser: &mut Parser) -> Result<Self> {
            let var = parser.match_uppercase_identifier()?.to_owned();
            Ok(var.into())
        }
    }
    impl FromStr for Clauses {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Clause {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Fact {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Rule {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Atoms {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Atom {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Term {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Terms {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Structure {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Constant {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    impl FromStr for Variable {
        type Err = anyhow::Error;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            Parser::parse(s)
        }
    }
    pub trait Parsable
    where
        Self: Sized,
    {
        fn parser_match(parser: &mut Parser) -> Result<Self>;
    }
    pub struct Parser<'source> {
        source: &'source str,
    }
    impl<'source> Parser<'source> {
        pub fn new(source: &'source str) -> Self {
            Self { source }
        }
        pub fn parse<T: Parsable>(source: &'source str) -> Result<T> {
            let mut parser = Self::new(source);
            let result = parser.match_type()?;
            parser.match_end()?;
            Ok(result)
        }
        pub fn trim(&mut self) {
            self.source = self.source.trim_start();
        }
        pub fn match_end(&mut self) -> Result<()> {
            self.trim();
            if !self.source.is_empty() {
                return ::anyhow::__private::Err(
                    ::anyhow::Error::msg({
                        let res = ::alloc::fmt::format(
                            format_args!("End not matched, found \'{0}\'", self.source),
                        );
                        res
                    }),
                );
            }
            Ok(())
        }
        pub fn match_token(&mut self, token: &str) -> Result<()> {
            self.trim();
            if !self.source.starts_with(token) {
                return ::anyhow::__private::Err(
                    ::anyhow::Error::msg({
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Token \'{0}\' not matched, found \'{1}\'",
                                token,
                                self.source,
                            ),
                        );
                        res
                    }),
                );
            }
            self.source = &self.source[token.len()..];
            Ok(())
        }
        pub fn match_regex(&mut self, regex: &str) -> Result<&str> {
            self.trim();
            let re_match = {
                const RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
                RE.get_or_init(|| {
                    Regex::new(
                            &{
                                let res = ::alloc::fmt::format(format_args!("^{0}", regex));
                                res
                            },
                        )
                        .unwrap()
                })
            }
                .find_at(&self.source, 0)
                .context({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Regex pattern \'{0}\' not matched, found \'{1}\'",
                            regex,
                            self.source,
                        ),
                    );
                    res
                })?;
            self.source = &self.source[re_match.end()..];
            Ok(re_match.as_str())
        }
        pub fn match_regex_captures<const N: usize>(
            &mut self,
            regex: &str,
        ) -> Result<[&str; N]> {
            self.trim();
            let (full_match, captures) = {
                const RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
                RE.get_or_init(|| {
                    Regex::new(
                            &{
                                let res = ::alloc::fmt::format(format_args!("^{0}", regex));
                                res
                            },
                        )
                        .unwrap()
                })
            }
                .captures(&self.source)
                .context({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "Regex pattern \'{0}\' not matched, found \'{1}\'",
                            regex,
                            self.source,
                        ),
                    );
                    res
                })?
                .extract::<{ N }>();
            self.source = &self.source[full_match.len()..];
            Ok(captures)
        }
        pub fn match_type<T: Parsable>(&mut self) -> Result<T> {
            self.trim();
            <T as Parsable>::parser_match(self)
        }
        pub fn match_sequence<T: Parsable + Debug>(
            &mut self,
            separator: &str,
            minimum: Option<usize>,
        ) -> Result<Vec<T>> {
            let backup_source = self.source;
            let result = self.match_sequence_unchecked(separator, minimum);
            if result.is_err() {
                self.source = backup_source;
            }
            result
        }
        fn match_sequence_unchecked<T: Parsable + Debug>(
            &mut self,
            separator: &str,
            minimum: Option<usize>,
        ) -> Result<Vec<T>> {
            let mut result = Vec::new();
            loop {
                let inner = self.match_type::<T>();
                if let Result::Ok(inner) = inner {
                    result.push(inner);
                } else {
                    break;
                }
                let _ = self.match_token(separator);
            }
            if let Some(min) = minimum {
                if ::anyhow::__private::not(result.len() >= min) {
                    return ::anyhow::__private::Err(
                        ::anyhow::Error::msg({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Matched only {0} element(s) in the sequence, expected at least {1}",
                                    result.len(),
                                    min,
                                ),
                            );
                            res
                        }),
                    );
                }
            }
            Ok(result)
        }
        pub fn match_identifier(&mut self) -> Result<&str> {
            self.match_regex(r"[\p{XID_Start}_][\p{XID_Continue}#]*")
        }
        pub fn match_lowercase_identifier(&mut self) -> Result<&str> {
            self.match_regex(r"[a-z][a-zA-Z0-9]*")
        }
        pub fn match_uppercase_identifier(&mut self) -> Result<&str> {
            self.match_regex(r"[A-Z][a-zA-Z0-9]*")
        }
        pub fn match_integer(&mut self) -> Result<&str> {
            self.match_regex(r"[1-9][0-9]*|0")
        }
        pub fn match_signed_integer(&mut self) -> Result<&str> {
            self.match_regex(r"[+-]?[1-9][0-9]*|0")
        }
    }
}
